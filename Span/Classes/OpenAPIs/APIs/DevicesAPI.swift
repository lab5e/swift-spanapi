//
// DevicesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class DevicesAPI {
    /**
     Create device
     
     - parameter collectionId: (path) This is the containing collection 
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createDevice(collectionId: String, body: Device, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Device?, _ error: Error?) -> Void)) {
        createDeviceWithRequestBuilder(collectionId: collectionId, body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create device
     - POST /collections/{collectionId}/devices
     - Create a new device. This will add a device to the collection. You must have write access to the collection.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) This is the containing collection 
     - parameter body: (body)  
     - returns: RequestBuilder<Device> 
     */
    open class func createDeviceWithRequestBuilder(collectionId: String, body: Device) -> RequestBuilder<Device> {
        var path = "/collections/{collectionId}/devices"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Device>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove device.
     
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deleteDevice(collectionId: String, deviceId: String, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Device?, _ error: Error?) -> Void)) {
        deleteDeviceWithRequestBuilder(collectionId: collectionId, deviceId: deviceId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Remove device.
     - DELETE /collections/{collectionId}/devices/{deviceId}
     - Remove device from collection
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - returns: RequestBuilder<Device> 
     */
    open class func deleteDeviceWithRequestBuilder(collectionId: String, deviceId: String) -> RequestBuilder<Device> {
        var path = "/collections/{collectionId}/devices/{deviceId}"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let deviceIdPreEscape = "\(APIHelper.mapValueToPathItem(deviceId))"
        let deviceIdPostEscape = deviceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deviceId}", with: deviceIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Device>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get payloads
     
     - parameter collectionId: (path) The collection ID. This is included in the request path. 
     - parameter deviceId: (path) The device ID. This is included in the request path. 
     - parameter limit: (query) Limit the number of payloads to return. The default is 512. (optional)
     - parameter start: (query) Start of time range. The default is 24 hours ago. Value is in milliseconds since epoch. (optional)
     - parameter end: (query) End of time range. The default is the current time stamp. Value is in milliseconds since epoch. (optional)
     - parameter offset: (query) The message offset based on the message ID. This parameter can&#39;t be combined with the start and end parameters. If no parameter is set the first N messages will be returned. If this parameter is set the next N messages (from newest to oldest) with message ID less than the offset will be returned. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listDeviceData(collectionId: String, deviceId: String, limit: Int? = nil, start: String? = nil, end: String? = nil, offset: String? = nil, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: ListDataResponse?, _ error: Error?) -> Void)) {
        listDeviceDataWithRequestBuilder(collectionId: collectionId, deviceId: deviceId, limit: limit, start: start, end: end, offset: offset).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get payloads
     - GET /collections/{collectionId}/devices/{deviceId}/data
     - List the data received from the device. Use the query parameters to control what data you retrieve. The maximumnumber of data points is 100.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) The collection ID. This is included in the request path. 
     - parameter deviceId: (path) The device ID. This is included in the request path. 
     - parameter limit: (query) Limit the number of payloads to return. The default is 512. (optional)
     - parameter start: (query) Start of time range. The default is 24 hours ago. Value is in milliseconds since epoch. (optional)
     - parameter end: (query) End of time range. The default is the current time stamp. Value is in milliseconds since epoch. (optional)
     - parameter offset: (query) The message offset based on the message ID. This parameter can&#39;t be combined with the start and end parameters. If no parameter is set the first N messages will be returned. If this parameter is set the next N messages (from newest to oldest) with message ID less than the offset will be returned. (optional)
     - returns: RequestBuilder<ListDataResponse> 
     */
    open class func listDeviceDataWithRequestBuilder(collectionId: String, deviceId: String, limit: Int? = nil, start: String? = nil, end: String? = nil, offset: String? = nil) -> RequestBuilder<ListDataResponse> {
        var path = "/collections/{collectionId}/devices/{deviceId}/data"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let deviceIdPreEscape = "\(APIHelper.mapValueToPathItem(deviceId))"
        let deviceIdPostEscape = deviceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deviceId}", with: deviceIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": limit?.encodeToJSON(),
            "start": start?.encodeToJSON(),
            "end": end?.encodeToJSON(),
            "offset": offset?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ListDataResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List devices in collection.
     
     - parameter collectionId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listDevices(collectionId: String, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: ListDevicesResponse?, _ error: Error?) -> Void)) {
        listDevicesWithRequestBuilder(collectionId: collectionId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List devices in collection.
     - GET /collections/{collectionId}/devices
     - List devices in collection
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path)  
     - returns: RequestBuilder<ListDevicesResponse> 
     */
    open class func listDevicesWithRequestBuilder(collectionId: String) -> RequestBuilder<ListDevicesResponse> {
        var path = "/collections/{collectionId}/devices"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ListDevicesResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Retrieve device
     
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func retrieveDevice(collectionId: String, deviceId: String, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Device?, _ error: Error?) -> Void)) {
        retrieveDeviceWithRequestBuilder(collectionId: collectionId, deviceId: deviceId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Retrieve device
     - GET /collections/{collectionId}/devices/{deviceId}
     - Retrieve a single device
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - returns: RequestBuilder<Device> 
     */
    open class func retrieveDeviceWithRequestBuilder(collectionId: String, deviceId: String) -> RequestBuilder<Device> {
        var path = "/collections/{collectionId}/devices/{deviceId}"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let deviceIdPreEscape = "\(APIHelper.mapValueToPathItem(deviceId))"
        let deviceIdPostEscape = deviceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deviceId}", with: deviceIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Device>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Send message to a device.
     
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func sendMessage(collectionId: String, deviceId: String, body: SendMessageRequest, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: SendMessageResponse?, _ error: Error?) -> Void)) {
        sendMessageWithRequestBuilder(collectionId: collectionId, deviceId: deviceId, body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Send message to a device.
     - POST /collections/{collectionId}/devices/{deviceId}/to
     - Send a message to the device
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path)  
     - parameter deviceId: (path)  
     - parameter body: (body)  
     - returns: RequestBuilder<SendMessageResponse> 
     */
    open class func sendMessageWithRequestBuilder(collectionId: String, deviceId: String, body: SendMessageRequest) -> RequestBuilder<SendMessageResponse> {
        var path = "/collections/{collectionId}/devices/{deviceId}/to"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let deviceIdPreEscape = "\(APIHelper.mapValueToPathItem(deviceId))"
        let deviceIdPostEscape = deviceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deviceId}", with: deviceIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<SendMessageResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update device. The device can be moved from one collection to another by setting the collection ID field to the new collection. You must have administrative access to both collections.
     
     - parameter existingCollectionId: (path)  
     - parameter deviceId: (path)  
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func updateDevice(existingCollectionId: String, deviceId: String, body: UpdateDeviceRequest, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Device?, _ error: Error?) -> Void)) {
        updateDeviceWithRequestBuilder(existingCollectionId: existingCollectionId, deviceId: deviceId, body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update device. The device can be moved from one collection to another by setting the collection ID field to the new collection. You must have administrative access to both collections.
     - PATCH /collections/{existingCollectionId}/devices/{deviceId}
     - Update device. The device can be moved from one collection to another by setting the collection ID field to the new collection. You must have administrative access to both collections.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter existingCollectionId: (path)  
     - parameter deviceId: (path)  
     - parameter body: (body)  
     - returns: RequestBuilder<Device> 
     */
    open class func updateDeviceWithRequestBuilder(existingCollectionId: String, deviceId: String, body: UpdateDeviceRequest) -> RequestBuilder<Device> {
        var path = "/collections/{existingCollectionId}/devices/{deviceId}"
        let existingCollectionIdPreEscape = "\(APIHelper.mapValueToPathItem(existingCollectionId))"
        let existingCollectionIdPostEscape = existingCollectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{existingCollectionId}", with: existingCollectionIdPostEscape, options: .literal, range: nil)
        let deviceIdPreEscape = "\(APIHelper.mapValueToPathItem(deviceId))"
        let deviceIdPostEscape = deviceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deviceId}", with: deviceIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Device>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
