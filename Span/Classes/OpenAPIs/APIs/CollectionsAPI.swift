//
// CollectionsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class CollectionsAPI {
    /**
     Broadcast message
     
     - parameter collectionId: (path)  
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func broadcastMessage(collectionId: String, body: BroadcastMessageRequest, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: MultiSendMessageResponse?, _ error: Error?) -> Void)) {
        broadcastMessageWithRequestBuilder(collectionId: collectionId, body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Broadcast message
     - POST /collections/{collectionId}/to
     - Broadcast a message to all devices in the collection. This request will always succeed if the collection exists, even if there are one or more send errors. Individual errors are returned as an array of error messages in the response. Use equivalent to resource for devices to send a message to single device.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path)  
     - parameter body: (body)  
     - returns: RequestBuilder<MultiSendMessageResponse> 
     */
    open class func broadcastMessageWithRequestBuilder(collectionId: String, body: BroadcastMessageRequest) -> RequestBuilder<MultiSendMessageResponse> {
        var path = "/collections/{collectionId}/to"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<MultiSendMessageResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Create collection
     
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createCollection(body: Collection, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Collection?, _ error: Error?) -> Void)) {
        createCollectionWithRequestBuilder(body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create collection
     - POST /collections
     - The returned collection is the collection stored in the backend. Defaults have been set. There are no required fields in a collection
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter body: (body)  
     - returns: RequestBuilder<Collection> 
     */
    open class func createCollectionWithRequestBuilder(body: Collection) -> RequestBuilder<Collection> {
        let path = "/collections"
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Collection>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete collection
     
     - parameter collectionId: (path) The ID of the collection you want to delete 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deleteCollection(collectionId: String, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Collection?, _ error: Error?) -> Void)) {
        deleteCollectionWithRequestBuilder(collectionId: collectionId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete collection
     - DELETE /collections/{collectionId}
     - You must have write access to the collection
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) The ID of the collection you want to delete 
     - returns: RequestBuilder<Collection> 
     */
    open class func deleteCollectionWithRequestBuilder(collectionId: String) -> RequestBuilder<Collection> {
        var path = "/collections/{collectionId}"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Collection>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get payloads
     
     - parameter collectionId: (path) The collection ID requested. This is included in the request path. 
     - parameter limit: (query) Limit the number of payloads to return. The default is 512. (optional)
     - parameter start: (query) Start of time range. The default is 24 hours ago. Value is in milliseconds since epoch. (optional)
     - parameter end: (query) End of time range. The default is the current time stamp. Value is in milliseconds since epoch. (optional)
     - parameter offset: (query) The message offset based on the message ID. This parameter can&#39;t be combined with the start and end parameters. If no parameter is set the first N messages will be returned. If this parameter is set the next N messages (from newest to oldest) with message ID less than the offset will be returned. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listCollectionData(collectionId: String, limit: Int? = nil, start: String? = nil, end: String? = nil, offset: String? = nil, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: ListDataResponse?, _ error: Error?) -> Void)) {
        listCollectionDataWithRequestBuilder(collectionId: collectionId, limit: limit, start: start, end: end, offset: offset).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get payloads
     - GET /collections/{collectionId}/data
     - List the data received from all the devices in the collection.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) The collection ID requested. This is included in the request path. 
     - parameter limit: (query) Limit the number of payloads to return. The default is 512. (optional)
     - parameter start: (query) Start of time range. The default is 24 hours ago. Value is in milliseconds since epoch. (optional)
     - parameter end: (query) End of time range. The default is the current time stamp. Value is in milliseconds since epoch. (optional)
     - parameter offset: (query) The message offset based on the message ID. This parameter can&#39;t be combined with the start and end parameters. If no parameter is set the first N messages will be returned. If this parameter is set the next N messages (from newest to oldest) with message ID less than the offset will be returned. (optional)
     - returns: RequestBuilder<ListDataResponse> 
     */
    open class func listCollectionDataWithRequestBuilder(collectionId: String, limit: Int? = nil, start: String? = nil, end: String? = nil, offset: String? = nil) -> RequestBuilder<ListDataResponse> {
        var path = "/collections/{collectionId}/data"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": limit?.encodeToJSON(),
            "start": start?.encodeToJSON(),
            "end": end?.encodeToJSON(),
            "offset": offset?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ListDataResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List collections
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listCollections(apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: ListCollectionResponse?, _ error: Error?) -> Void)) {
        listCollectionsWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List collections
     - GET /collections
     - Lists all the collections that one of your teams owns.
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - returns: RequestBuilder<ListCollectionResponse> 
     */
    open class func listCollectionsWithRequestBuilder() -> RequestBuilder<ListCollectionResponse> {
        let path = "/collections"
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ListCollectionResponse>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Retrieve collection
     
     - parameter collectionId: (path) The collection ID of the collection you are requesting 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func retrieveCollection(collectionId: String, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Collection?, _ error: Error?) -> Void)) {
        retrieveCollectionWithRequestBuilder(collectionId: collectionId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Retrieve collection
     - GET /collections/{collectionId}
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) The collection ID of the collection you are requesting 
     - returns: RequestBuilder<Collection> 
     */
    open class func retrieveCollectionWithRequestBuilder(collectionId: String) -> RequestBuilder<Collection> {
        var path = "/collections/{collectionId}"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Collection>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update collection
     
     - parameter collectionId: (path) The ID of the collection. This is assigned by the backend. 
     - parameter body: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func updateCollection(collectionId: String, body: Collection, apiResponseQueue: DispatchQueue = SpanAPI.apiResponseQueue, completion: @escaping ((_ data: Collection?, _ error: Error?) -> Void)) {
        updateCollectionWithRequestBuilder(collectionId: collectionId, body: body).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update collection
     - PATCH /collections/{collectionId}
     - You must have write access to the collection, ie. you must administer it
     - API Key:
       - type: apiKey X-API-Token 
       - name: APIToken
     - parameter collectionId: (path) The ID of the collection. This is assigned by the backend. 
     - parameter body: (body)  
     - returns: RequestBuilder<Collection> 
     */
    open class func updateCollectionWithRequestBuilder(collectionId: String, body: Collection) -> RequestBuilder<Collection> {
        var path = "/collections/{collectionId}"
        let collectionIdPreEscape = "\(APIHelper.mapValueToPathItem(collectionId))"
        let collectionIdPostEscape = collectionIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{collectionId}", with: collectionIdPostEscape, options: .literal, range: nil)
        let URLString = SpanAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Collection>.Type = SpanAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
